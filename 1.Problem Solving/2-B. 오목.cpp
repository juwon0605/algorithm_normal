/*
문제 2-B
제목 오목
내용
오목은 잘 알려진 2인용 보드게임으로, 두 참가자가 검은색과 흰색 바둑돌을
번갈아 바둑판에 놓다가 가로, 세로, 대각선 방향 중 한 방향으로 같은 색의
바둑돌 5개가 연결될 경우 그 색을 가진 참가자가 이기는 게임이다. 두 참가
자는 본인의 색이 칠해진 바둑돌들을 충분히 가지고 게임을 시작하며, 본인
의 차례에 바둑판의 원하는 위치에 바둑돌 하나를 놓는다. 검은색 바둑돌을
선택한 참가자가 먼저 바둑돌을 놓으며, 이후에는 두 참가자가 번갈아 가면
서 바둑돌 하나씩을 놓게 된다. 바둑판은 정사각형 모양으로, 바둑돌을 놓을
수 있는 위치는 가로 15 × 세로 15, 총 225개이다. 이들의 좌표를 (x,y)로
표시하기로 하자(단, x = 1,...,15, y = 1,...,15).


입력으로 바둑돌이 놓이는 좌표 225개가 차례로 주어질 때, 승부가 결정되는
최초의 순간(몇 번 째 바둑돌이 놓이는 시점인지)과 승자가 누구인지(W: 흰
색, B: 검은색)를 출력하는 프로그램을 작성하시오. 단, 한 방향으로 같은 색
바둑돌이 정확히 5개만 연결되는 경우에만 승부가 결정되며(예 1의 9번째
수), 바둑돌을 놓는 순간에 6개 이상이 한줄로 연결되는 경우(예를 들어 연
결된 2개와 연결된 3개 사이에 바둑돌이 하나 놓여져 6개가 연결되는, 예 2
의 11번째 수와 같은 경우)에는 승부가 결정되지 않는다고 가정한다. 그러
나, 한 방향으로 6개 이상의 바둑돌이 연결되는 순간이라도, 다른 방향으로
정확히 5개가 연결되는 경우(예 3의 19번째 수와 같이 5개의 연결과 6개의
연결이 동시에 생기는 경우)는 승부가 결정된다. 바둑돌이 5개 연결되기 전
에 실질적으로 승패가 결정되는 경우(예를 들어 양쪽이 막히지 않고 4개의
바둑돌이 연결되는, 예 1의 7번째 수와 같은 경우[흔히 “열린 4”라고 이야기
함], 한쪽만 막힌 4개의 바둑돌 연결이 두 개 동시에 나타나는, 예 4의 13번
째 수와 같은 경우[흔히 “4, 4”라고 이야기함] 등)도 있으나, 이런 경우는 바
둑돌이 5개 연결될 때까지 승부가 결정되지 않는 것으로 간주한다.
사용할 수 있는 언어는 C, C++로 제한한다. 프로그램의 실행 제한 시간은 1
초이다. C++의 경우 main 함수 내의 시작 지점에 다음 내용을 추가함으로
써 cin 입력 속도를 개선할 수 있다.
std::ios::sync_with_stdio(false);
입력 형식
입력은 표준 입력으로 다음과 같이 주어진다. 첫 줄에는 테스트케이스의 수
T(≤ 100)가 주어진다. 각 테스트케이스는 정확히 225줄로 구성되며(같은 위
치에 바둑돌을 놓는 경우는 없음), 각 줄에는 각 바둑돌의 x, y 좌표
(1 ≤ x,y ≤ 15)가 공백 하나를 사이에 두고 주어진다.
출력 형식
출력은 표준 출력으로 표시하며, T줄로 구성된다. 각 테스트케이스 별로 몇
번째 수에 승패가 결정되었는지, 승자가 누구인지(W: 흰색, B: 검은색)를 빈
칸 하나를 사이에 두고 한 줄에 출력한다.
예
입력
2
3 3 // 검은색이 (3, 3)에 놓임
4 3 // 흰색이 (4, 3)에 놓임
4 4
4 5
5 5
5 6
6 6 // 검은색 열린 4: 실질적으로 승패가 결정되나, 일단 계속 진행함
6 7
7 7 // 검은색 바둑돌 5개가 연결되어 경기 종료함
8 5
... // 이후 215줄 모두 테스트케이스 1번에 해당
3 3 // 두 번째 테스트케이스 시작
4 3
4 4
5 4
5 5
6 5
7 7
7 6
8 8
5 6
6 6 // 검은색 바둑돌 6개가 연결되어 경기 계속함
8 7 // 흰색 바둑돌 5개가 연결되어 경기 종료함
... // 이후 213줄 모두 테스트케이스 2번에 해당
(empty line)
출력
9 B
12 W
(empty line
*/

#define _CRT_SECURE_NO_WARNINGS

#include<iostream>
#include<string>
using namespace std;

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	freopen("input.txt", "rt", stdin);
	int map[17][17] = { 0 };
	int dy[8] = { 1,1,0,-1,-1,-1,0,1 }, dx[8] = { 0,1,1,1,0,-1,-1,-1 };
	string PLAYER = "0BW";
	int t, x, y, winnerIdx, inputCase;
	cin >> t;
	while (t--) {
		for (int i = 0; i < 17; i++) {
			for (int j = 0; j < 17; j++) map[i][j] = 0;
		}
		winnerIdx = 0;
		for (inputCase = 1; inputCase <= 225; inputCase++) {
			cin >> x >> y;
			if (winnerIdx > 0) continue;
			map[y][x] = (inputCase % 2 == 1 ? 1 : 2);
			for (int i = 0; i < 4; i++) {
				int cnt = 0;
				int cnt1 = 1;
				int cnt2 = 1;
				while (1) {
					int yy = y + dy[i] * cnt1;
					int xx = x + dx[i] * cnt1;
					if (map[y][x] != map[yy][xx]) break;
					cnt1++;
				}
				while (1) {
					int yy = y + dy[i + 4] * cnt2;
					int xx = x + dx[i + 4] * cnt2;
					if (map[y][x] != map[yy][xx]) break;
					cnt2++;
				}
				cnt = cnt1 + cnt2 - 1;
				if (cnt == 5) {
					winnerIdx = map[y][x];
					cout << inputCase << " " << PLAYER[winnerIdx] << endl;
					break;
				}
			}
		}
	}
	return 0;
}

/*
모범 답안
	시간복잡도
		O(TN^3) (N=15)
	공간복잡도
		O(N^2) (N=15)
*/