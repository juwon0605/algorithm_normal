/*
문제 3-A
제목 움직이는 하노이의 탑
내용
하노이의 탑(Tower of Hanoi) 문제는 잘 알려진 퍼즐 문제로서, 여러 개의
막대와 가운데 구멍이 뚫린 크기가 다른 원반(disc) 여러 개가 주어질 때 하
나의 목표 막대에 원반을 크기 순으로 정렬하여 놓는 문제이다. 인하는 다음
과 같이 변형된 하노이의 탑 문제를 풀고자 한다. 먼저 그림과 같이 여러 개
의 막대들이 원형으로 배치되어 있으며, 각 막대들에는 크기가 모두 다른 원
반이 정확히 하나씩만 놓여 있다. 인하는 수레를 하나 가지고 있는데, 이 수
레에도 막대가 한 개 있으며, 처음에 수레는 비어 있다. 인하는 막대들로 구
성된 원 주변으로 이 수레를 시계 반대 방향으로 움직이면서, 수레 위에서
큰 원반이 아래에, 작은 원반이 위에 있도록 원반들을 쌓아 나가는데, 수레
를 가장 적게 움직이면서 최종적으로는 모든 원반들이 순서에 맞게 수레 위
에 쌓여 있게 하고 싶다. 그런데 수레에 일단 원반을 올려놓으면, 다시 내려
놓을 수는 없다. 예를 들어 그림과 같이 6개의 막대에 원반들이 놓여 있고,
그림에 표시된 지점에서 출발하여 시계 반대방향으로 진행한다면, 인하가 막
대들 주변을 한 번 돌아 출발 지점으로 돌아왔을 때 크기 6인 원반을 맨 밑
에, 크기 5인 원반을 그 위에 놓여있게 할 수 있다. 다음 한 바퀴를 돌 때는
크기 4인 원반을 그 위에 놓고 돌아올 수 있으며, 세 번째 바퀴에서는 크기
3, 2, 1인 원반들을 차례로 올려놓으면서 돌아올 수 있으므로 인하는 세 바
퀴만에 목표를 달성할 수 있다. 원반들의 배치가 주어질 때 인하가 목표를
달성하려면 최소 몇 바퀴를 돌아야 하는지 구하는 프로그램을 작성하시오.
 사용할 수 있는 언어는 C, C++로 제한한다. 프로그램의 실행 시간은 5초
이다. C++의 경우 main 함수 내의 시작 지점에 다음 내용을 추가하면 cin
입력 속도가 개선되는 경우도 있다.
std::ios::sync_with_stdio(false);
입력 형식
입력은 표준 입력으로 다음과 같이 주어진다. 첫 줄에는 테스트케이스의 수
T(≤ 100)가 주어진다. 각 테스트케이스의 첫 번째 줄에는 원반의 개수
N(≤ 10000)이 주어진다. 두 번째 줄에는 수레의 출발 지점부터 시계 반대
방향으로 진행하여 원래 지점으로 돌아올 때 차례로 만나게 되는 원반의 크
기를 나타내는 자연수(1,...,N)들이 공백을 하나 사이에 두고 주어진다. (단,
자연수들은 모두 다르다.) 이후에 T - 1개 테스트케이스도 같은 형식으로 주
어진다.
출력 형식
출력은 표준 출력으로 표시하며, T줄로 이루어진다. 각 테스트케이스 별로
최소 바퀴 수를 한 줄에 하나씩 출력한다.
예
입력
2
6
3 4 2 6 5 1
5
1 2 3 4 5
(empty line)
출력
3
5
(empty line)
*/

#define _CRT_SECURE_NO_WARNINGS

#include<iostream>
using namespace std;

int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);
	freopen("input.txt", "rt", stdin);
	int flag[102];
	int t, n, res, now;
	cin >> t;
	while (t--) {
		fill(flag, flag + 102, 0);
		res = 0;
		cin >> n;
		while (n--) {
			cin >> now;
			if (flag[now + 1] == 0) res++;
			flag[now] = 1;
		}
		cout << res << endl;
	}
	return 0;
}

/*
모범 답안
	시간복잡도
		O(TN)
	공간복잡도
		O(N)
*/